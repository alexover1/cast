array_test :: () {
	array: [5] int;

	printf("The array at %p has %lld elements\n", *array, array.count);

	for 0..array.count-1 {
		array[it] = (it+1) * 3;
		printf("%p: %lld\n", *array[it], array[it]);
	}
}

slice_test :: () {
	array: [5] int;

	for 0..array.count-1 {
		array[it] = (it+1) * 3;
	}

	slice: [] int;
	slice.data = *array[0];
	slice.count = array.count;

	slice[2] = 10;

	for 0..array.count-1 {
		printf("%lld\n", slice[it]);
	}
	
	printf("The sum of the array is %lld\n", sum(slice));
}

struct_packing :: () {
	My_Struct :: struct {
		byte: u8;
		width: u32;
		height: u64;
	}

	// 0xaa, 0xcafe, 0xc8
	my_struct := My_Struct.{170, 51966, 200};

	packed_array: [2] u64;

	// Note: Once we have implicit array to slice this will go away.
	slice: [] u64;
	slice.data = *packed_array[0];
	slice.count = packed_array.count;

	pack_struct((*my_struct) as *u8, 13, slice); // TODO: size_of

	for 0..packed_array.count-1 {
		format := "0x%llx\n";
		printf(format.data, packed_array[it]);
	}
}

main :: () -> int {
	array_test();
	slice_test();
	struct_packing();
	return 0;
}

sum :: (array: [] int) -> int {
	sum: int;
	for 0..array.count-1 {
		sum += array[it];
	}
	return sum;
}

pack_struct :: (input: *u8, input_size: int, output: []u64) {
    output_index: u64 = 0;

    cursor := input;
    end := input + input_size;

    while cursor < end {
        array_index := output_index / 64;
        bit_index := output_index % 64;
        mask := cursor.* as u64 << bit_index;
        output[array_index] |= mask;
        output_index += 8;
		cursor += 1;
    }
}

printf :: (format: *u8, ..) #foreign;
