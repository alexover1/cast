array_test :: () {
	printf("====================\n");

	array: [5] int;

	printf("The array at %p has %lld elements\n", *array, array.count);

	for 0..array.count-1 {
		array[it] = (it+1) * 3;
		printf("%p: %lld\n", *array[it], array[it]);
	}
}

slice_test :: () {
	printf("====================\n");

	array: [5] int;

	for 0..array.count-1 {
		array[it] = (it+1) * 3;
	}

	slice: [] int;
	slice.data = *array[0];
	slice.count = array.count;

	slice[2] = 10;

	for 0..array.count-1 {
		printf("%lld\n", slice[it]);
	}
	
	printf("The sum of the array is %lld\n", sum(slice));
}

struct_packing :: () {
	printf("====================\n");

	My_Struct :: struct {
		byte: u8;
		width: u32;
		height: u64;
	}

	// 0xaa, 0xcafe, 0xc8
	my_struct := My_Struct.{170, 51966, 200};

	packed_array := pack_struct((*my_struct) as *u8, 16); // TODO: size_of

	printf("Packed:\n");
	for 0..packed_array.count-1 {
		format := "  0x%llx\n";
		printf(format.data, packed_array[it]);
	}
}

main :: () -> int {
	// array_test();
	// slice_test();
	struct_packing();
	return 0;
}

sum :: (array: [] int) -> int {
	sum: int;
	for 0..array.count-1 {
		sum += array[it];
	}
	return sum;
}

pack_struct :: (input: *u8, input_size: u64) -> []u64 {
	words := (input_size + 7) / 8;

	printf("Needs at least %lld words\n", words);

	output: []u64;
	output.data = malloc(words * 8) as *u64;
	output.count = words as int;

	for 0..input_size-1 {
		array_index := it / 8;
		bit_index := (it*8) % 64;
		next_word := (input + it).* as u64;
		mask := next_word << bit_index as u64;
		output[array_index] |= mask;

		printf("array_index = %lld, bit_index = %lld, next_word = %llu, mask = %llu\n", array_index, bit_index, next_word, mask);
	}

	return output;
}

print_binary :: (number: u64) {
	if number >> 1 {
		print_binary(number >> 1);
	}
	if number & 1  putchar("1")
	else           putchar("0");
}

printf :: (format: *u8, ..) #foreign;
putchar :: (char: u8) #foreign;

malloc :: (size: u64) -> *void #foreign;
free :: (pointer: *void) #foreign;
calloc :: (count: u64, member_size: u64) -> *void #foreign;
realloc :: (pointer: *void, new_size: u64) -> *void #foreign;